# 谈谈对volatile的理解

    java虚拟机提供的 轻量级 的同步机制

三大特性：

- 保证可见性
- 不保证原子性
- **禁止指令重排**

# JMM(java memory model)是什么

    java内存模型：定义的是线程与主内存之间的关系，即在虚拟机中线程中将变量(堆内存中的 实例变量、静态字段、和构成数组对象 )
    存储到内存和从内存中取出变量的实现细节。但不包括局部变量与方法参数，因为后者是线程私有的，不会被共享，不存在竞争问题

JMM关于同步的规定：

1. 线程解锁前，必须把共享变量的值刷新回主内存
2. 线程加锁前，必须读取主内存的最新值，到自己的工作内存
3. 加锁和解锁是同一把锁

jvm运行程序的实体是线程，每个线程创建时JVM都会创建一个工作内存（**工作内存是哪个区**），工作内存是每个线程的私有区域，而java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域
所有线程都可以访问，但`线程对变量的操作（读取赋值等）必须在工作内存中进行，首先要将变量从主内存拷贝到自己的工作内存空间，然后对变量进行操作，操作完成后再讲变量写会主内存`，不能直接操作主内存中的变量，
各个线程中的工作内存中存储着主内存中的变量副本拷贝，因此不同的线程键无法访问对象的工作内存，线程间的通信（赋值）必须通过主 内存来完成

- 主内存：计算机内存
- 工作内存：CPU的寄存器和高速缓存

为什么有两个内存? cpu在处理数据的时候，并不是直接从内存找那个读取数据，读取数据的优先级是：寄存器(一级缓存)>高速内存(二级缓存)>内存>硬盘 当线程计算完后，这些缓存的数据在适当的时候应该被写会内存

注：java内存模型的可见性，指的是当主内存区域中的值被某个线程写入更改后，其他线程会马上知晓更改后的值，并重新得到更改后的值， 这里使用了`MESI`和`总线嗅探技术`

MESI(CPU缓存一致性协议)
当CPU写数据时，会将自己线程与其他持有本数据的线程标记以下状态（是通过总线嗅探技术实现的）

- M：缓存有效，数据被当前线程修改，和内存中的数据不一致，最新数据值存在于本线程（CPU缓存就是本cache中）中
- E: 缓存有效，数据和内存中的数据一致，数据只存在于本线程（CPU缓存就是本cache中）中
- S：缓存有效，数据和内存中的数据一致，数据存在于很多线程（CPU缓存就是本cache中）中
- I：数据失效

总线嗅探 
- 每个处理器通过监听`在总线上传播的数据`来检查自己的缓存值是否过期了，当处理器发现自己的缓存行对应的数据被修改，就会将当前处理器的缓存行设置为无效状态， 
当处理器对这个数据进行修改操作的时候，会重新从内存中把数据读取到处理器缓存中

总线风暴
- 由于Volatile的MESI缓存一致性协议，需要不断的 `从主内存嗅探和CAS循环`，无效的交互会导致总线带宽达到峰值。因此不要大量使用volatile关键字，
  至于什么时候使用volatile、什么时候用锁以及Syschonized都是需要根据实际场景的。


    